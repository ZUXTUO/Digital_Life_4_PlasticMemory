<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Isla</title>
    <style>
      body { 
        font-family: Arial, sans-serif; 
        margin: 0; 
        padding: 0; 
        overflow: hidden;
        background: #f0f0f0;
      }
      
      canvas { 
        position: fixed;
        top: 0;
        left: 0;
        display: block;
        background: url('images/bg.png') no-repeat center center;
        background-size: auto 100%;
        cursor: grab;
        /* 确保在移动设备上正确显示 */
        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
        box-sizing: border-box;
      }
      
      canvas:active {
        cursor: grabbing;
      }
      
      /* 指令选择按钮样式 */
      .command-button {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 20px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      
      .command-button:hover {
        background: rgba(0, 0, 0, 0.9);
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      }
      
      /* 弹窗样式 */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2000;
        display: none;
        justify-content: center;
        align-items: center;
      }
      
      .modal-content {
        background: white;
        border-radius: 15px;
        padding: 20px;
        max-width: 400px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }
      
      .modal-header {
        text-align: center;
        margin-bottom: 20px;
        font-size: 18px;
        font-weight: bold;
        color: #333;
      }
      
      .emotion-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        gap: 10px;
        margin-bottom: 20px;
      }
      
      .emotion-button {
        background: #f0f0f0;
        border: 2px solid #ddd;
        border-radius: 10px;
        padding: 12px 8px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
      }
      
      .emotion-button:hover {
        background: #e0e0e0;
        border-color: #999;
        transform: translateY(-2px);
      }
      
      .modal-close {
        background: #ff6b6b;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px 20px;
        font-size: 14px;
        cursor: pointer;
        width: 100%;
        transition: background 0.2s ease;
      }
      
      .modal-close:hover {
        background: #ff5252;
      }
      
      /* 状态显示 */
      .status-display {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 10px;
        padding: 8px 16px;
        font-size: 14px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .status-display.show {
        opacity: 1;
      }
      


    </style>
    <script>
      // 防御：旧版本脚本可能调用全局 onStopAnimation，这里提供空实现避免报错
      window.onStopAnimation = window.onStopAnimation || function(){};
    </script>
    <script type="text/JavaScript" src="driver/emotedriver.js?v=2" charset="UTF-8"></script>
    <script type="text/JavaScript" src="driver/emoteplayer.js?v=2" charset="UTF-8"></script>
  </head>
  <body onload="start()">

    <canvas id="canvas" width="1920" height="1080"></canvas>
    
    <!-- 指令选择按钮 -->
    <button class="command-button" id="commandButton">选择表情</button>
    

    
    <!-- 状态显示 -->
    <div class="status-display" id="statusDisplay"></div>
    
    <!-- 弹窗 -->
    <div class="modal-overlay" id="modalOverlay">
      <div class="modal-content">
        <div class="modal-header">选择表情</div>
        <div class="emotion-grid" id="emotionGrid">
          <!-- 动态生成表情按钮 -->
        </div>
        <button class="modal-close" id="modalClose">关闭</button>
      </div>
    </div>

    <script>
      // 数据文件命名模板
      const DATA_BASE_PREFIX = "data/pm_emt_isl_"; // 相对本站根目录
      const DATA_HEAD_SUFFIX = "_頭のみ.emtbytes";
      const DATA_BODY_SUFFIX = "_体のみ.emtbytes";
      const DATA_JSON_SUFFIX = ".json";

      // 全局变量
      let currentSkinData = null; // 当前皮肤的JSON数据
      let isPlayingAnimation = false; // 是否正在播放动画
      let defaultAnimation = null; // 默认动画名称
      let player = null; // 全局player变量

      function generateSkinList() {
        const list = [];
        for (let c2 = 'a'.charCodeAt(0); c2 <= 'o'.charCodeAt(0); c2++) {
          const code = `a${String.fromCharCode(c2)}`;
          const base = `${DATA_BASE_PREFIX}${code}`;
          list.push({
            code,
            label: `isl_${code}`,
            head: `${base}${DATA_HEAD_SUFFIX}`,
            body: `${base}${DATA_BODY_SUFFIX}`,
            json: `${base}${DATA_JSON_SUFFIX}`,
          });
        }
        return list;
      }

      // 加载JSON文件
      async function loadSkinJSON(jsonUrl) {
        try {
          const response = await fetch(jsonUrl);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const jsonData = await response.json();
          console.log('JSON数据加载成功:', jsonData);
          return jsonData;
        } catch (error) {
          console.error('加载JSON文件失败:', error);
          return null;
        }
      }

      // 显示状态信息
      function showStatus(message, duration = 3000) {
        const statusDisplay = document.getElementById('statusDisplay');
        statusDisplay.textContent = message;
        statusDisplay.classList.add('show');
        
        setTimeout(() => {
          statusDisplay.classList.remove('show');
        }, duration);
      }

      // 根据指令搜索动画
      function searchAnimationByCommand(command) {
        if (!currentSkinData || !currentSkinData.Phiz) {
          return null;
        }
        
        // 遍历所有表情分类
        for (const phiz of currentSkinData.Phiz) {
          if (phiz.phiz_name === command) {
            // 随机选择一个动画
            const randomIndex = Math.floor(Math.random() * phiz.phiz_anime_name.length);
            return phiz.phiz_anime_name[randomIndex];
          }
        }
        
        return null;
      }

      // 播放动画并返回默认状态
      async function playAnimationAndReturn(animationName) {
        if (!animationName || isPlayingAnimation) {
          return;
        }
        
        isPlayingAnimation = true;
        
        try {
          // 先停止当前播放的动画
          if (player.mainTimelineLabel && player.mainTimelineLabel !== "") {
            // 使用内部方法停止当前动画
            if (player.playerId && typeof EmotePlayer_StopTimeline === 'function') {
              EmotePlayer_StopTimeline(player.playerId, player.mainTimelineLabel);
            }
          }
          
          // 设置新的动画标签
          player.mainTimelineLabel = animationName;
          
          // 强制刷新模型状态
          if (player.invalidateDrawing) {
            player.invalidateDrawing();
          }
          
          // 获取动画的总帧数来估算播放时间
          let animationDuration = 3000; // 默认3秒
          try {
            if (typeof EmotePlayer_GetTimelineTotalFrameCount === 'function' && player.playerId) {
              const totalFrames = EmotePlayer_GetTimelineTotalFrameCount(player.playerId, animationName);
              if (totalFrames > 0) {
                // 假设30fps，计算播放时间
                animationDuration = (totalFrames / 30) * 1000;
                console.log(`动画 ${animationName} 总帧数: ${totalFrames}, 估算时长: ${animationDuration}ms`);
              }
            }
          } catch (e) {
            console.log('无法获取动画帧数，使用默认时长');
          }
          
          // 等待动画播放完成
          await new Promise((resolve) => {
            setTimeout(resolve, Math.max(2000, animationDuration)); // 至少等待2秒
          });
          
          // 动画播放完成后，返回默认状态
          if (defaultAnimation) {
            // 先停止当前动画
            if (player.mainTimelineLabel && player.mainTimelineLabel !== "") {
              if (player.playerId && typeof EmotePlayer_StopTimeline === 'function') {
                EmotePlayer_StopTimeline(player.playerId, player.mainTimelineLabel);
              }
            }
            
            // 设置默认动画
            player.mainTimelineLabel = defaultAnimation;
            
            // 强制刷新
            if (player.invalidateDrawing) {
              player.invalidateDrawing();
            }
            
            // 延迟后再次确认默认状态
            setTimeout(() => {
              player.mainTimelineLabel = defaultAnimation;
              if (player.invalidateDrawing) {
                player.invalidateDrawing();
              }
              console.log('已返回默认状态:', defaultAnimation);
            }, 200);
            
            //showStatus('已返回默认状态');
          } else {
            console.log('未设置默认动画');
          }
          
        } catch (error) {
          console.error('播放动画失败:', error);
          showStatus('播放动画失败');
        } finally {
          isPlayingAnimation = false;
        }
      }

      // 处理表情选择
      function handleEmotionSelection(emotionName) {
        if (!emotionName || emotionName.trim() === '') {
          return;
        }
        
        const trimmedEmotion = emotionName.trim();
        console.log('选择表情:', trimmedEmotion);
        
        // 搜索对应的动画
        const animationName = searchAnimationByCommand(trimmedEmotion);
        
        if (animationName) {
          playAnimationAndReturn(animationName);
          closeModal(); // 关闭弹窗
        } else {
          showStatus(`未找到表情"${trimmedEmotion}"对应的动画`);
        }
      }

      // 打开弹窗
      function openModal() {
        const modalOverlay = document.getElementById('modalOverlay');
        modalOverlay.style.display = 'flex';
        
        // 生成表情按钮
        generateEmotionButtons();
      }

      // 关闭弹窗
      function closeModal() {
        const modalOverlay = document.getElementById('modalOverlay');
        modalOverlay.style.display = 'none';
      }

      // 生成表情按钮
      function generateEmotionButtons() {
        const emotionGrid = document.getElementById('emotionGrid');
        emotionGrid.innerHTML = '';
        
        if (!currentSkinData || !currentSkinData.Phiz) {
          emotionGrid.innerHTML = '<p style="text-align: center; color: #666;">暂无表情数据</p>';
          return;
        }
        
        // 过滤掉"普通"表情，只显示其他表情
        const emotions = currentSkinData.Phiz.filter(phiz => phiz.phiz_name !== '普通');
        
        emotions.forEach(phiz => {
          const button = document.createElement('button');
          button.className = 'emotion-button';
          button.textContent = phiz.phiz_name;
          button.onclick = () => handleEmotionSelection(phiz.phiz_name);
          emotionGrid.appendChild(button);
        });
      }



      function loadSkinToPlayer(player, skin) {
        player.scale = 0.9; // 增大默认大小为0.9
        
        // 先加载JSON数据
        return loadSkinJSON(skin.json).then((jsonData) => {
          if (jsonData) {
            currentSkinData = jsonData;
            console.log(`皮肤 ${skin.code} 的JSON数据已加载`);
            
            // 设置默认动画（如果有的话）
            if (jsonData.Phiz) {
              const normalPhiz = jsonData.Phiz.find(p => p.phiz_name === '普通');
              if (normalPhiz && normalPhiz.phiz_anime_name.length > 0) {
                defaultAnimation = normalPhiz.phiz_anime_name[0];
                console.log('默认动画设置为:', defaultAnimation);
              }
            }
          }
          
          // 然后加载模型文件
          return player.promiseLoadDataFromURL(skin.head, skin.body).then(() => {
            // 模型加载完成后，立即设置默认状态
            if (defaultAnimation) {
              // 先确保没有其他动画在播放
              if (player.mainTimelineLabel && player.mainTimelineLabel !== "") {
                if (player.playerId && typeof EmotePlayer_StopTimeline === 'function') {
                  EmotePlayer_StopTimeline(player.playerId, player.mainTimelineLabel);
                }
              }
              
              player.mainTimelineLabel = defaultAnimation;
              
              // 强制刷新确保状态正确显示
              if (player.invalidateDrawing) {
                player.invalidateDrawing();
              }
              
              // 延迟后再次确认默认状态
              setTimeout(() => {
                player.mainTimelineLabel = defaultAnimation;
                if (player.invalidateDrawing) {
                  player.invalidateDrawing();
                }
                console.log('模型加载完成，设置默认状态:', defaultAnimation);
              }, 500);
            }
          });
        });
      }

      function start() {
        // 初始化渲染用隐藏画布 - 使用2倍分辨率保证精度
        const renderWidth = 1920 * 2;
        const renderHeight = 1080 * 2;
        EmotePlayer.createRenderCanvas(renderWidth, renderHeight);

        const canvas = document.getElementById('canvas');
        player = new EmotePlayer(canvas);
        
        // 设置默认位置（居中但往上一点点）
        player.coord = [0, -50];
        player.scale = 0.9; // 增大默认大小

        // 背景隐藏小窗口：播放 emote_logo_d2.emtbytes
        const logoCanvas = document.createElement('canvas');
        logoCanvas.id = 'logoCanvas';
        logoCanvas.width = 320;
        logoCanvas.height = 240;
        logoCanvas.style.display = 'none'; // 隐藏
        document.body.appendChild(logoCanvas);
        const logoPlayer = new EmotePlayer(logoCanvas);
        logoPlayer.scale = 0.5; // 适当缩放
        logoPlayer.promiseLoadDataFromURL('emote_logo_d2.emtbytes')
          .then(() => {
            const labels = logoPlayer.mainTimelineLabels;
            if (labels && labels.length > 0) {
              logoPlayer.mainTimelineLabel = labels[0];
            }
          })
          .catch(console.error);

        // 指令选择按钮事件处理
        const commandButton = document.getElementById('commandButton');
        commandButton.addEventListener('click', openModal);



        // 弹窗关闭事件处理
        const modalClose = document.getElementById('modalClose');
        const modalOverlay = document.getElementById('modalOverlay');
        
        modalClose.addEventListener('click', closeModal);
        modalOverlay.addEventListener('click', (e) => {
          if (e.target === modalOverlay) {
            closeModal();
          }
        });

        // 拖拽功能
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // 鼠标事件
        canvas.addEventListener('mousedown', (e) => {
          isDragging = true;
          dragOffsetX = e.clientX - player.coord[0];
          dragOffsetY = e.clientY - player.coord[1];
          canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
          if (isDragging) {
            player.coord = [e.clientX - dragOffsetX, e.clientY - dragOffsetY];
          }
        });

        canvas.addEventListener('mouseup', () => {
          isDragging = false;
          canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
          isDragging = false;
          canvas.style.cursor = 'grab';
        });

        // 滚轮缩放
        canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const scaleChange = e.deltaY > 0 ? 0.9 : 1.1;
          player.scale = Math.max(0.1, Math.min(2.0, player.scale * scaleChange));
        });

        // 触控事件支持
        let initialDistance = 0;
        let initialScale = 0.9;
        let touchDragOffsetX = 0;
        let touchDragOffsetY = 0;

        canvas.addEventListener('touchstart', (e) => {
          e.preventDefault(); // 防止页面滚动
          if (e.touches.length === 1) {
            // 单指拖拽
            const touch = e.touches[0];
            touchDragOffsetX = touch.clientX - player.coord[0];
            touchDragOffsetY = touch.clientY - player.coord[1];
          } else if (e.touches.length === 2) {
            // 双指缩放
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = Math.sqrt(
              Math.pow(touch2.clientX - touch1.clientX, 2) +
              Math.pow(touch2.clientY - touch1.clientY, 2)
            );
            initialScale = player.scale;
          }
        });

        canvas.addEventListener('touchmove', (e) => {
          e.preventDefault(); // 防止页面滚动
          if (e.touches.length === 1) {
            // 单指拖拽
            const touch = e.touches[0];
            player.coord = [touch.clientX - touchDragOffsetX, touch.clientY - touchDragOffsetY];
          } else if (e.touches.length === 2) {
            // 双指缩放
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.sqrt(
              Math.pow(touch2.clientX - touch1.clientX, 2) +
              Math.pow(touch2.clientY - touch1.clientY, 2)
            );
            const scaleChange = currentDistance / initialDistance;
            player.scale = Math.max(0.1, Math.min(2.0, initialScale * scaleChange));
          }
        });

        // 防止触摸事件引起页面滚动
        canvas.addEventListener('touchend', (e) => {
          e.preventDefault();
        });

        // 窗口大小变化时重新调整画布
        function resizeCanvas() {
          // 获取实际的视口尺寸
          const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
          const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
          
          // 设置画布的实际渲染尺寸为2倍分辨率
          canvas.width = viewportWidth * 2;
          canvas.height = viewportHeight * 2;
          
          // 设置CSS显示尺寸为视口大小，这样既保证了精度又适配了网页
          canvas.style.width = viewportWidth + 'px';
          canvas.style.height = viewportHeight + 'px';
          
          // 确保画布在移动设备上正确显示
          canvas.style.maxWidth = '100vw';
          canvas.style.maxHeight = '100vh';
        }

        window.addEventListener('resize', resizeCanvas);
        
        // 确保初始尺寸正确
        resizeCanvas();
        
        // 在页面完全加载后再次调整尺寸
        window.addEventListener('load', resizeCanvas);
        
        // 随机选择皮肤函数
        function selectRandomSkin() {
          const skins = generateSkinList();
          const randomIndex = Math.floor(Math.random() * skins.length);
          const randomSkin = skins[randomIndex];
          loadSkinToPlayer(player, randomSkin);
        }

        // 自动选择第一个随机模型
        setTimeout(selectRandomSkin, 100);
        
        // 暴露全局函数供外部调用
        window.handleExternalCommand = handleEmotionSelection;
        window.playAnimationAndReturn = playAnimationAndReturn;
        
        // 显示使用说明
        setTimeout(() => {
          //showStatus('网站已加载完成！点击"选择表情"按钮选择表情', 5000);
        }, 2000);
      }
    </script>
  </body>
</html>
